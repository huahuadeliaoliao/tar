"""Session management endpoints."""

import json
from datetime import datetime, timezone
from typing import List, Literal, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Response, status
from fastapi.responses import PlainTextResponse, StreamingResponse
from sqlalchemy import literal
from sqlalchemy.orm import Session

from app.database import get_db
from app.dependencies import get_current_user
from app.models import Message, User
from app.models import Session as SessionModel
from app.schemas import (
    ExportedMessage,
    MessageResponse,
    SessionCreate,
    SessionDetailResponse,
    SessionExportResponse,
    SessionResponse,
    SessionUpdate,
)
from app.services.agent import ASSISTANT_ARTIFACT_TOOL_NAME

router = APIRouter(prefix="/api/sessions", tags=["Sessions"])


@router.post("", response_model=SessionResponse, status_code=status.HTTP_201_CREATED)
def create_session(session_data: SessionCreate, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """Create a new session for the authenticated user.

    Args:
        session_data: Title and default model for the new session.
        user: Authenticated user resolved from the access token.
        db: Database session injected by FastAPI.

    Returns:
        SessionResponse: The persisted session object.
    """
    new_session = SessionModel(user_id=user.id, title=session_data.title, model_id=session_data.model_id)

    db.add(new_session)
    db.commit()
    db.refresh(new_session)

    return new_session


@router.get("", response_model=List[SessionResponse])
def list_sessions(user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """Return all sessions owned by the user.

    Args:
        user: Authenticated user whose sessions should be listed.
        db: Database session injected by FastAPI.

    Returns:
        List[SessionResponse]: Sessions sorted by last update time.
    """
    sessions = (
        db.query(SessionModel).filter(SessionModel.user_id == user.id).order_by(SessionModel.updated_at.desc()).all()
    )

    return sessions


@router.get("/{session_id}", response_model=SessionDetailResponse)
def get_session(
    session_id: int,
    user: User = Depends(get_current_user),
    include_internal: bool = Query(False, description="Include assistant artifact messages generated from tools."),
    db: Session = Depends(get_db),
):
    """Return a session plus its messages.

    Args:
        session_id: Identifier of the requested session.
        user: Authenticated user, used to verify ownership.
        include_internal: When False, omit assistant artifact messages generated by tools.
        db: Database session injected by FastAPI.

    Returns:
        SessionDetailResponse: The session metadata and ordered message list.

    Raises:
        HTTPException: When the session does not exist or is not owned by the
        user.
    """
    session = db.query(SessionModel).filter(SessionModel.id == session_id, SessionModel.user_id == user.id).first()

    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found")

    messages = db.query(Message).filter(Message.session_id == session_id).order_by(Message.sequence).all()

    if not include_internal:
        messages = [
            msg for msg in messages if not (msg.role == "assistant" and msg.tool_name == ASSISTANT_ARTIFACT_TOOL_NAME)
        ]

    message_responses = [MessageResponse.model_validate(msg) for msg in messages]

    return SessionDetailResponse(session=session, messages=message_responses)


@router.patch("/{session_id}", response_model=SessionResponse)
def update_session(
    session_id: int, session_data: SessionUpdate, user: User = Depends(get_current_user), db: Session = Depends(get_db)
):
    """Update mutable session fields such as title or model.

    Args:
        session_id: Identifier of the session to update.
        session_data: Payload containing optional updates.
        user: Authenticated user, used to verify ownership.
        db: Database session injected by FastAPI.

    Returns:
        SessionResponse: The updated session.

    Raises:
        HTTPException: When the session does not exist or is not owned by the
        user.
    """
    session = db.query(SessionModel).filter(SessionModel.id == session_id, SessionModel.user_id == user.id).first()

    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found")

    if session_data.title is not None:
        session.title = session_data.title

    if session_data.model_id is not None:
        session.model_id = session_data.model_id

    db.commit()
    db.refresh(session)

    return session


@router.get("/{session_id}/export")
def export_session(
    session_id: int,
    response: Response,
    export_format: Literal["json", "ndjson", "markdown"] = Query("json", alias="format"),
    include_tools: bool = Query(True, description="Include tool call metadata in the export payload."),
    include_internal: bool = Query(False, description="Include assistant artifact messages generated from tools."),
    since: Optional[datetime] = Query(
        None, description="Only include messages created at or after this ISO8601 timestamp."
    ),
    download: bool = Query(False, description="Force download by adding a Content-Disposition header."),
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Export a session's messages in JSON, NDJSON, or Markdown formats."""
    session = db.query(SessionModel).filter(SessionModel.id == session_id, SessionModel.user_id == user.id).first()

    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found")

    message_query = db.query(Message).filter(Message.session_id == session_id)

    if since:
        if since.tzinfo is not None:
            since_naive = since.astimezone(timezone.utc).replace(tzinfo=None)
        else:
            since_naive = since
        message_query = message_query.filter(Message.created_at >= literal(since_naive))

    messages = message_query.order_by(Message.sequence).all()

    if not include_internal:
        messages = [
            msg for msg in messages if not (msg.role == "assistant" and msg.tool_name == ASSISTANT_ARTIFACT_TOOL_NAME)
        ]

    exported_at = datetime.now(timezone.utc)
    exported_at_str = exported_at.isoformat()

    session_payload = SessionResponse.model_validate(session)

    export_messages: List[ExportedMessage] = []
    for msg in messages:
        message_data = {
            "id": msg.id,
            "sequence": msg.sequence,
            "role": msg.role,
            "content": msg.content,
            "tool_call_id": msg.tool_call_id,
            "tool_name": msg.tool_name,
            "tool_input": msg.tool_input,
            "tool_output": msg.tool_output,
            "model_id": msg.model_id,
            "created_at": msg.created_at,
        }

        if not include_tools:
            message_data.update(
                tool_call_id=None,
                tool_name=None,
                tool_input=None,
                tool_output=None,
            )

        export_messages.append(ExportedMessage(**message_data))

    message_count = len(export_messages)
    filename_extension = {"json": "json", "ndjson": "ndjson", "markdown": "md"}[export_format]
    disposition_filename = f"session-{session_id}.{filename_extension}"

    if export_format == "json":
        payload = SessionExportResponse(
            session=session_payload,
            messages=export_messages,
            exported_at=exported_at,
            message_count=message_count,
        )
        response.headers["X-Exported-At"] = exported_at_str
        response.headers["X-Export-Message-Count"] = str(message_count)
        if download:
            response.headers["Content-Disposition"] = f'attachment; filename="{disposition_filename}"'
        return payload

    if export_format == "ndjson":

        def ndjson_iter():
            session_entry = {
                "type": "session",
                "session": session_payload.model_dump(mode="json"),
                "exported_at": exported_at_str,
                "message_count": message_count,
            }
            yield json.dumps(session_entry, ensure_ascii=False) + "\n"
            for message in export_messages:
                data = message.model_dump(mode="json")
                data["type"] = "message"
                yield json.dumps(data, ensure_ascii=False) + "\n"

        stream = StreamingResponse(ndjson_iter(), media_type="application/x-ndjson")
        stream.headers["X-Exported-At"] = exported_at_str
        stream.headers["X-Export-Message-Count"] = str(message_count)
        if download:
            stream.headers["Content-Disposition"] = f'attachment; filename="{disposition_filename}"'
        return stream

    if export_format == "markdown":
        title = session_payload.title or f"Session {session_id}"

        lines = [
            f"# {title}",
            "",
            f"- Session ID: {session_payload.id}",
            f"- Model: {session_payload.model_id}",
            f"- Created At: {session_payload.created_at.isoformat()}",
            f"- Updated At: {session_payload.updated_at.isoformat()}",
            f"- Exported At: {exported_at_str}",
            "",
        ]

        for message in export_messages:
            timestamp = message.created_at.isoformat()
            role_header = message.role.capitalize()
            lines.append(f"## {role_header} Â· {timestamp}")
            content = message.content or ""
            lines.append(content if content else "_No content provided._")

            if include_tools and any(
                [message.tool_call_id, message.tool_name, message.tool_input, message.tool_output]
            ):
                lines.append("")
                lines.append("**Tool Call**")
                tool_details = {
                    "tool_call_id": message.tool_call_id,
                    "tool_name": message.tool_name,
                    "tool_input": message.tool_input,
                    "tool_output": message.tool_output,
                }
                lines.append("```json")
                lines.append(json.dumps(tool_details, ensure_ascii=False, indent=2))
                lines.append("```")

            lines.append("")

        markdown_body = "\n".join(lines).rstrip() + "\n"

        markdown_response = PlainTextResponse(markdown_body, media_type="text/markdown")
        markdown_response.headers["X-Exported-At"] = exported_at_str
        markdown_response.headers["X-Export-Message-Count"] = str(message_count)
        if download:
            markdown_response.headers["Content-Disposition"] = f'attachment; filename="{disposition_filename}"'
        return markdown_response

    raise HTTPException(status_code=status.HTTP_406_NOT_ACCEPTABLE, detail="Unsupported export format")


@router.delete("/{session_id}", response_model=dict)
def delete_session(session_id: int, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """Delete a session and cascade delete its messages.

    Args:
        session_id: Identifier of the session to delete.
        user: Authenticated user, used to verify ownership.
        db: Database session injected by FastAPI.

    Returns:
        dict: Confirmation message.

    Raises:
        HTTPException: When the session does not exist or is not owned by the
        user.
    """
    session = db.query(SessionModel).filter(SessionModel.id == session_id, SessionModel.user_id == user.id).first()

    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found")

    db.delete(session)
    db.commit()

    return {"message": "Session deleted"}
